%% inverseTransformSampleND.m
%
% DISTRIBUTION STATEMENT A. Approved for public release. Distribution is 
% unlimited.
% 
% This material is based upon work supported by the Federal Aviation 
% Administration under Air Force Contract No. FA8702-15-D-0001. Any 
% opinions, findings, conclusions or recommendations expressed in this 
% material are those of the author(s) and do not necessarily reflect the 
% views of the Federal Aviation Administration.
% 
% Â© 2024 Massachusetts Institute of Technology.
% 
% Subject to FAR52.227-11 Patent Rights - Ownership by the contractor 
% (May 2014)
% 
% The software/firmware is provided to you on an As-Is basis
% 
% Delivered to the U.S. Government with Unlimited Rights, as defined in 
% DFARS Part 252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright
% notice, U.S. Government rights in this work are defined by DFARS 
% 252.227-7013 or DFARS 252.227-7014 as detailed above. Use of this work 
% other than as specifically authorized by the U.S. Government may violate 
% any copyrights that exist in this work.
%
% inverseTransformSampleND.m
% 
% Performs inverse transform sampling on a multidimensional empirical
% probability matrix for generating joint random distributions.  This
% implementation is currently capped at 4-dimensional input, for better 
% efficiency.
%

% Input:
% - probIn: probabilty matrix for the input variables
% - vals:   structure where each element contains values for the bins for
%           each variable
% - n:      number of output joint samples to generate
%
% Output:
% - samp:   structure containing the n output joint samples, one element 
%           for each element in "vals"
%
% Frank Robasky, MIT-LL, 1/2024

function [samp] = inverseTransformSampleND(probIn, vals, n)

    % threshold governing bin selection for output values
    rndThresh = 0.5;
    % progress increment for diagnostic progress message
    progressInc = 0.1;
    % set random seed, for reproducible output
    rng(215);

    nDim = ndims(probIn);
    samp = nan(n,nDim);
    names = fieldnames(vals);
    probSize = size(probIn);
    probSize = probSize(1);
   
    % uniform random numbers, one set for each dimension, for indexing into
    % CDFs
    rnd = rand(n, nDim);

    % generate static idx string lists for use in subsequent indexing, for
    % efficiency
    for k = 1:nDim
        if k==1
            idxList{k} = sprintf('idx(%d)', k);
        else
            idxList{k} = sprintf('%s,idx(%d)', idxList{k-1}, k);
        end
    end

    % generate set of static probability matrices, one for each dimension.
    % These are generated by summing over all dimensions greater than the
    % specified dimension.  The final element is the full input probability
    % matrix.
    for k = 1:nDim
        if k==nDim
            probS.(['dim' num2str(k)]) = probIn;
        else
            probS.(['dim' num2str(k)]) = sum(probIn,[k+1:nDim]);
        end
    end

    % find marginal CDF for the first dimension
    xtr1 = probS.dim1;
    xtr1 = xtr1 / sum(xtr1);
    cdf1 = cumsum(xtr1);

    % loop through all desired output points.  Stop when the desired number
    % of output samples are reached.
    i = 1;

    % for diagnostic progress indicator
    nextProgress = progressInc;
    fprintf('Progress:');

    % main loop
    subs_init = repmat({':'}, 1, nDim);  
    while i <= n
        if i >= nextProgress * n
            fprintf(' %.0f%%', nextProgress * 100);
            nextProgress = nextProgress + progressInc;
        end

        rnd = rand(1,nDim);
        idx = nan(1,nDim);

        % First dimension.  Find CDF bin that corresponds to random number.
        % Look up the corresponding value for this bin to generate output
        % random value.
        minDiff = min(abs(rnd(1)-cdf1));
        idxN = find(minDiff == (abs(rnd(1)-cdf1)));
        if numel(idxN)>1 && rnd(1)<rndThresh
            idx(1) = idxN(end);
        elseif numel(idxN)>1 && rnd(1)>=rndThresh
            idx(1) = idxN(1);
        else
            idx(1) = idxN;
        end
        samp(i,1) = vals.(names{1})(idx(1));

        % for remaining input dimensions
        for m = 2:nDim
            % exit out of loop if any previous samples are missing
            if any(isnan(idx(1:m-1))); continue; end
            prob = probS.(sprintf('dim%d',m));
            % Extract a probability vector for the desired dimension.
            % These options are currently hard-coded for efficiency, capped 
            % for 10D input.  The dynamic solutions attempted thus far (e.g.
            % using eval operator and text strings, or anonymous functions)
            % have been found to be expensive.
            if m==2
                xtr = prob(idx(1),:);
            elseif m==3
                xtr = prob(idx(1),idx(2),:);
            elseif m==4
                xtr = prob(idx(1),idx(2),idx(3),:);
            elseif m==5
                xtr = prob(idx(1),idx(2),idx(3),idx(4),:);
            elseif m==6
                xtr = prob(idx(1),idx(2),idx(3),idx(4),idx(5),:);
            elseif m==7
                xtr = prob(idx(1),idx(2),idx(3),idx(4),idx(5),idx(6),:);
            elseif m==8
                xtr = prob(idx(1),idx(2),idx(3),idx(4),idx(5),idx(6),...
                    idx(7),:);
            elseif m==9
                xtr = prob(idx(1),idx(2),idx(3),idx(4),idx(5),idx(6),...
                    idx(7),idx(8),:);
            elseif m==10
                xtr = prob(idx(1),idx(2),idx(3),idx(4),idx(5),idx(6),...
                    idx(7),idx(8),idx(9),:);
            else
                % The above hard coded extractions are replaced with
                % the following generalized code of poorer efficiency
                subs = repmat({':'}, 1, nDim);
                subs(1:m-1) = num2cell(idx(1:m-1));
                subs{end} = ':';
                xtr = prob(subs{:});
            end

            xtr = reshape(xtr,probSize,1);
            if sum(xtr)==0; continue; end
            % Generate a CDF from this extract.
            xtr = xtr / sum(xtr);
            cdf = cumsum(xtr);
            % Find CDF bin that corresponds to random number. Look up the 
            % corresponding value for this bin to generate output random 
            % value.
            minDiff = min(abs(rnd(m)-cdf));
            idxN = find(minDiff == (abs(rnd(m)-cdf)));
            if numel(idxN)>1 && rnd(m)<rndThresh
                idx(m) = idxN(end);
            elseif numel(idxN)>1 && rnd(m)>=rndThresh
                idx(m) = idxN(1);
            else
                idx(m) = idxN;
            end
            samp(i,m) = vals.(names{m})(idx(m));
        end

        % only increment counter if no missing samples
        if ~any(isnan(samp(i,:)))
            i = i + 1;
        else
            continue
        end
    end

    fprintf('\n');

end